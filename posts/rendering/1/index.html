<!doctype html>
<meta charset="utf-8">
<title>FPS.js</title>
<link rel="stylesheet" href="/media/css/styles.css" />
<link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/default.min.css" />
<header class="centered">
    <div>
    <h1><a href="/">Building a networked FPS in the browser</a></h1>
    </div>
</header>
<div class="centered">
    <div id="container">
        <h1 id="abriefasideonshaders">A brief aside on shaders</h1>

<p>So, in the <a href="#rendering">last article</a>, we drew a triangle to the screen. To do so, we defined
an array of vertices and sent them to the graphics card, and we defined an enigmatic little
function that would send a shader program to the graphics card:</p>

<pre><code>// create a shader program (a strategy for
// rendering OpenGL primitives) and send it
// to the OpenGL server.
function init_program() {

    // create a handle for the program (which is comprised of a vertex and fragment shader),
// and handles for the vertex and fragment shaders. 
    var program = gl.createProgram()
      , vertex_shader = gl.createShader(gl.VERTEX_SHADER)
      , fragment_shader = gl.createShader(gl.FRAGMENT_SHADER)

    // send OpenGL the source code of our shaders.
    gl.shaderSource(vertex_shader, 
        'attribute vec3 position;\nvoid main() { gl_Position = vec4( position, 1.0 ); }')
    gl.shaderSource(fragment_shader, 
        'void main() { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); }')

    // ...and tell OpenGL to compile them.
    gl.compileShader(vertex_shader)
    gl.compileShader(fragment_shader)

    // attach both compiled shaders to the shader program.
    gl.attachShader(program, vertex_shader)
    gl.attachShader(program, fragment_shader)

    // link it, so we have a complete program!
    gl.linkProgram(program)
    return program
}
</code></pre>

<p>A high level read of the code yields us the following procedure:</p>

<ul>
<li>Create a program object.</li>
<li>Create a vertex shader.</li>
<li>Send our vertex shader source code to the graphics card.</li>
<li>Compile it.</li>
<li>Create a fragment shader.</li>
<li>Send our fragment shader source code to the graphics card.</li>
<li>Compile it.</li>
<li>Attach the fragment and vertex shaders to the program.</li>
<li>Tell the program to link.</li>
</ul>

<p>Cool. It sounds remarkably similar to compiling and linking C programs, actually:</p>

<pre><code>cat &gt; greeting.h &lt;&lt;EOF
    #ifndef GREETING_H
    #define GREETING_H

        int say_hi(char* arg);

    #endif
EOF
cat &gt; main.c &lt;&lt;EOF
    #include "greeting.h"

    int main(int argc, char** argv) {
        say_hi(argv[argc-1]);
        return 0;
    }
EOF
cat &gt; greeting.c &lt;&lt;EOF
    #include "greeting.h"
    #include &lt;stdio.h&gt;

    int say_hi(char* arg) {
        printf("hello %s\n", arg);
    }
EOF

gcc main.c greeting.c -o greeting
./greeting world
# hello world
</code></pre>

<p>That last line &mdash; <code>gcc main.c greeting.c -o greeting_program</code> actually takes our two files,
compiles them into "object files", and then links those object files to produce the 
complete program "greeting".</p>

<p>It's important to note what's going on here: there are two files that share knowledge of a single function,
<code>say_hi</code>. Only one has the actual definition of <code>say_hi</code>, the other just calls it and relies on the linking
process to complete the program.</p>

<p>So from this we can surmise that shader programs must be sharing some kind of state: otherwise there'd
really be no reason to link them. Further, they come in two "kinds" of source program &mdash; fragment and
vertex &mdash; that must be linked. Okay, cool.</p>

<blockquote>
  <h3 id="notabene">Nota bene:</h3>
  
  <p>For the rest of the article, we'll
  be using the source code from the <a href="#rendering">previous article</a>,
  and only manipulating the shader source code (the two calls to 
  <code>gl.shaderSource</code> in <code>init_program</code>). </p>
</blockquote>

<p><strong>So what state are we sharing between the vertex and fragment shader?</strong></p>

<p>When we link the vertex and fragment shaders into a complete shader program, we're actually defining
two important (and interrelated) parts of OpenGL's <strong>rendering pipeline</strong>. </p>

<p><em>Wait, what?</em> Okay, let's put ourselves in the shoes of OpenGL in our program. We've just received
a draw call. What do we see?</p>

<pre><code>    gl.drawArrays(gl.TRIANGLES, 0, num_vertices)
</code></pre>

<p>Okay, we know we're supposed to be drawing <code>TRIANGLES</code>. We know that to draw a triangle, we need 3
vertices, one for each corner of the triangle. We also know that when we get data, we're supposed
to start slicing it into triangles starting at the first element (<code>0</code> above), and we'll be receiving
<code>num_vertices</code> vertices. We'll do our best to turn that data into triangles.</p>

<p>Where's that data coming from, though?</p>

<pre><code>    // enable the first stream of vertex data:
    gl.enableVertexAttribArray(0)
    gl.drawArrays(gl.TRIANGLES, 0, num_vertices)
</code></pre>

<p>Oh, we've enabled a <code>vertexAttribArray</code> at location 0! Okay. so we should expect one stream of data coming
in, on the first channel. Okay. What data are we talking about?</p>

<pre><code>    // use data from the following buffer:
    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer)
    gl.enableVertexAttribArray(0)
    gl.drawArrays(gl.TRIANGLES, 0, num_vertices)
</code></pre>

<p>What does a vertex look like, though? Remember, that buffer just contains a flat array of numbers. Is it a
stream of <code>x</code>, <code>y</code> values as integers? Or is it <code>x</code>, <code>y</code>, <code>z</code> coordinates in floating point? Oh, woe betide
that vain, capricious client, telling us to draw triangles without even telling us what her vertex data
looks like!</p>

<p>Waitaminute.</p>

<pre><code>    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer)
    // the vertices in `vertex_buffer` look like this:
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0)
    gl.enableVertexAttribArray(0)
    gl.drawArrays(gl.TRIANGLES, 0, num_vertices)
</code></pre>

<blockquote>
  <p>A note: the buffer data looks like this:
  <code>[x, y, z, x, y, z, x, y, z]</code>.
  We could potentially have a buffer with extra data
  between vertices, e.g.  <code>[x, y, z, LOL, ROFL, x, y, z, LOL, ROFL]</code>.</p>
</blockquote>

<p>Oh! The vertex data at stream <code>0</code> is <code>3</code> <code>FLOAT</code> elements wide. It's already in floating point format &mdash; we don't
need to convert them into floats ourselves (the <code>false</code> above). There are <code>0</code> elements in the array data between
vertices, and the data in the buffer starts at the <code>0</code>th index. <strong>OK!</strong> Let's get drawing. </p>

<p>Wait, hold up.</p>

<p>We're making a two dimensional drawing of these triangles, right? How does the client want us to take
his three dimensional vertexes and turn them into two dimensional positions on the screen?</p>

<p>Furthermore, after we know how the client wants us to project those vertices onto the screen, and we're starting to draw
pixels, what does the client actually want us to put in those pixels? I mean, we'll know we're supposed to draw into 
these pixels, but what goes in 'em?</p>

<p><strong>Oh.</strong></p>

<pre><code>    // use this program to transform the vertices into screen space,
    // and to determine the RGBA value of the pixels that need drawn.
    gl.useProgram(program)
    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer)
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0)
    gl.enableVertexAttribArray(0)
    gl.drawArrays(gl.TRIANGLES, 0, num_vertices)
</code></pre>

<p>So we'll use the shader program we defined in <code>init_program</code> in the last lesson to determine how to transform incoming
vertices onto the screen, and how to determine a color value for pixels that need to be rendered. What does our
vertex shader look like right now?</p>

<pre><code>attribute vec3 position;

void main() {
    gl_Position = vec4(position, 1.0);
}
</code></pre>

<p><canvas id="normal" class="imgright" style="background:#CCC"></p>

<script type="text/javascript">

    (function(){
    var canvas = document.getElementById('normal')
      , gl = canvas.getContext('experimental-webgl')

    // here's our vertex data.
    var vertices = [
         -0.5, -0.5, 0
      ,   0.0,  0.5, 0
      ,   0.5, -0.5, 0
    ]

    // create a shader program &mdash; a strategy for
    // rendering OpenGL primitives &mdash; and send it
    // to the OpenGL server.
    function init_program() {
        var program = gl.createProgram()
          , vertex_shader = gl.createShader(gl.VERTEX_SHADER)
          , fragment_shader = gl.createShader(gl.FRAGMENT_SHADER)

        gl.shaderSource(vertex_shader, 'attribute vec3 position;\nvoid main() { gl_Position = vec4( position, 1.0 ); }')
        gl.shaderSource(fragment_shader, 'void main() { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); }')
        gl.compileShader(vertex_shader)
        gl.compileShader(fragment_shader)

        gl.attachShader(program, vertex_shader)
        gl.attachShader(program, fragment_shader)
        gl.linkProgram(program)
        return program
    }

    // send our vertex data to the OpenGL server.
    function init_vertex() {
        var buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW)
        return buffer
    }

    function draw(program, vertex) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

        // tell OpenGL to use our shader program
        gl.useProgram(program)

        // tell OpenGL that we're talking about the
        // vertexes we sent it earlier.
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex)
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(0)

        // issue a draw command to OpenGL.
        gl.drawArrays(gl.TRIANGLES, 0, vertices.length/3)
    }

    var program = init_program()
      , vertex = init_vertex()

    // set the background color, RGBA (from 0.0 to 1.0).
    gl.clearColor(0, 0, 0, 1.0)
    draw(program, vertex)

    })()
</script>

<p>There's only one "attribute" of the incoming data that we're worried about &mdash; <code>position</code>. We want to hand it back
to OpenGL directly because we're just drawing 2D graphics, hence the <code>gl_Position = vec4(position, 1.0);</code>. Pretty simple.</p>

<p><strong>Let's mess with it.</strong></p>

<p>What happens when we scale that position by <code>0.5</code>?</p>

<p><canvas id="scaled" class="imgright" style="background:#CCC"></p>

<script type="text/javascript">

    (function(){
    var canvas = document.getElementById('scaled')
      , gl = canvas.getContext('experimental-webgl')

    // here's our vertex data.
    var vertices = [
         -0.5, -0.5, 0
      ,   0.0,  0.5, 0
      ,   0.5, -0.5, 0
    ]

    // create a shader program &mdash; a strategy for
    // rendering OpenGL primitives &mdash; and send it
    // to the OpenGL server.
    function init_program() {
        var program = gl.createProgram()
          , vertex_shader = gl.createShader(gl.VERTEX_SHADER)
          , fragment_shader = gl.createShader(gl.FRAGMENT_SHADER)

        gl.shaderSource(vertex_shader, 'attribute vec3 position;\nvoid main() { gl_Position = vec4( position*0.5, 1.0 ); }')
        gl.shaderSource(fragment_shader, 'void main() { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); }')
        gl.compileShader(vertex_shader)
        gl.compileShader(fragment_shader)

        gl.attachShader(program, vertex_shader)
        gl.attachShader(program, fragment_shader)
        gl.linkProgram(program)
        return program
    }

    // send our vertex data to the OpenGL server.
    function init_vertex() {
        var buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW)
        return buffer
    }

    function draw(program, vertex) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

        // tell OpenGL to use our shader program
        gl.useProgram(program)

        // tell OpenGL that we're talking about the
        // vertexes we sent it earlier.
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex)
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(0)

        // issue a draw command to OpenGL.
        gl.drawArrays(gl.TRIANGLES, 0, vertices.length/3)
    }

    var program = init_program()
      , vertex = init_vertex()

    // set the background color, RGBA (from 0.0 to 1.0).
    gl.clearColor(0, 0, 0, 1.0)
    draw(program, vertex)

    })()
</script>

<p>Oh, the triangle got smaller. Awesome. </p><!--/ins-->
    </div>
</div>
<footer class="centered">
    <div>
        <a href="http://github.com/chrisdickinson/" target="_blank">
            <img src="https://secure.gravatar.com/avatar/f70956bdb907c2f8b39ff624ea925ccd?s=140" />
        </a>
        <aside>
        <p><em>Chris Dickinson</em> is a hacker living in Lawrence, KS.
        <p>He enjoys drawing, coffee, Starcraft, and chatting about JavaScript.
        <p>You can follow him <a href="http://twitter.com/isntitvacant/">on twitter</a> or
           <a href="http://github.com/chrisdickinson/">on github</a>. He&rsquo;d very much appreciate
           it!
        </aside>
    </div>
</footer>
<script src="/media/js/showdown.js"></script>
<script src="/media/js/highlight.js"></script>
<script>[].slice.call(document.getElementsByTagName('code')).forEach(function(el) { hljs.highlightBlock(el, '  ') })</script>
<script src="/media/js/page.js"></script>
