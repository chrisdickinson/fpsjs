<!doctype html>
<meta charset="utf-8">
<title>FPS.js</title>
<link rel="stylesheet" href="/media/css/styles.css" />
<link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/default.min.css" />
<header class="centered">
    <div>
    <h1><a href="/">Building a networked FPS in the browser</a></h1>
    </div>
</header>
<div class="centered">
    <div id="container">
        <h1 id="texturesanddrawcalls">Textures and draw calls</h1>

<p>In the last lesson, we talked at length about the OpenGL rendering pipeline; touching
on <strong>vertex attributes</strong> and what they mean to our shader program. We also defined what
the <strong>vertex and fragment shaders</strong> contribute to the rendering path &mdash; and learned that it's
fairly straightforward to send uniform (unchanging) data into the rendering path that can
be access by both the vertex and fragment shaders. In particular, we sent a floating
point uniform representing the current progress through a period (3 seconds), and used
it to bounce the triangle in and out; as well as to fade from white to black and back to
white. We marveled at how many <strong>parallel</strong> operations our GPU is capapble of performing.</p>

<p>What now?</p>

<p><img src="/media/img/painterly.jpg" alt="left" title="" /></p>

<p>Take a look at these screenshots from Minecraft. They're using a <a href="http://painterlypack.net/">custom texture pack</a>
to change the look and feel of the game.</p>

<p>Obviously, we're not anywhere close to having a game &mdash; we're still working out OpenGL --
but it's important to note the importance of textures: they play a large part in defining
the look and feel of our game. More than that, since we'll have <em>direct</em>, <strong>programmatic</strong>
access to the textures in our vertex and fragment shaders, we can use them to send a lot
of data to the GPU in a very efficient manner.</p>

<h2 id="howdoweloadtextures">How do we load textures?</h2>

<p>OpenGL allows a lot of flexibility in configuring textures. We can send 1, 2, or even 3 dimensional
textures to our shader program. We can define the edge behavior of the texture &mdash; that is, if you try to sample
a texture outside of it's width or height, it will behave as we tell it to. We can also define what
happens when the texture is subsampled (when the camera is far away from the texture), as well as what
we see when it is supersampled (when the camera is close to the texture). </p>

<p>Let's define a new function &mdash; <code>load_texture</code> &mdash; that takes a path to an image and returns a configured
OpenGL texture object.</p>

<pre><code>function load_texture(path) {
  // use the built in `Image` constructor provided to javascript.
  var img = new Image
    , texture = gl.createTexture()

  img.src = path

  img.onload = function() {
    // put the image data in the correct order for OpenGL.
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)

    // set the active texture object to `texture`.
    gl.bindTexture(gl.TEXTURE_2D, texture)

    // we want to write a 2D image, at the first level of detail,
    // to the current texture handle. store the data internally as (r,g,b,a).
    // the incoming data is already in (r,g,b,a) format, and it's defined in
    // unsigned bytes (0-255). pull that data from `img`.
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img)

    // as we get closer to the texture, use linear scaling to supersample the image.
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)

    // as we get further away from the texture, use linear scaling to subsample the image.
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)

    // set the behavior for sampling a coordinate from the texture outside of the width
    // of the image:
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)

    // as well as outside the height of the image:
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
  }
  return texture
} 
</code></pre>

<p>The result of calling this function is a configured texture object. 
<a href="http://www.opengl.org/sdk/docs/man/xhtml/glTexParameter.xml">There are many other options we could configure</a>, 
but this will do for now.</p>

<p>To actually start using our texture, we'll have to modify our fragment shader and our
draw call from the previous program:</p>

<pre><code>// our fragment shader:
#ifdef GL_ES
precision highp float;
#endif

uniform float time;

// this is our texture!
uniform sampler2D texture;

void main() {
    // put time into degrees (2 cycles / iteration)
    float x = time * 720.0;

    // put x in the range [0, 2]
    x = sin(radians(x)) + 2.0;

    // and back into [0, 1].
    x = x / 2.0;

    // lookup a pixel from our texture using our
    // current screen coordinates divided by our screen resolution.
    vec4 texture_color = texture2D(texture, gl_FragCoord.xy / 640.0);
    vec4 x_vec = vec4(x, x, x, 1.0);

    gl_FragColor = x_vec * texture_color;
}
</code></pre>

<p>As for the draw call:</p>

<pre><code>// we'll add a parameter for `texture` to our draw call:
function draw(program, vertex, texture) {
    var time_location
      , texture_location

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
    gl.useProgram(program)
    time_location = program.time_location || gl.getUniformLocation(program, 'time')
    program.time_location = time_location

    // note: we cache the location of `uniform sampler2D texture` just
    // like the time.
    texture_location = program.texture_location || gl.getUniformLocation(program, 'texture')
    program.texture_location = texture_location

    // set the active texture unit to 0.
    gl.activeTexture(gl.TEXTURE0)

    // bind the texture to the current active texture unit.
    gl.bindTexture(gl.TEXTURE_2D, texture)

    // tell our program that the variable `uniform sampler2D texture` refers to texture unit 0.
    gl.uniform1i(texture_location, 0)

    gl.uniform1f(time_location, (Date.now() % 3000) / 3000)
    gl.bindBuffer(gl.ARRAY_BUFFER, vertex)
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0)
    gl.enableVertexAttribArray(0)
    gl.drawArrays(gl.TRIANGLES, 0, vertices.length/3)
}
</code></pre>

<p>Okay, now our <code>draw</code> call will accept a texture object. Let's modify our loop:</p>

<pre><code>// we're just loading the texture and passing it into the draw call now.
var program = init_program()
  , vertex = init_vertex()
  , texture = load_texture('/media/img/painterly.jpg')

gl.clearColor(0, 0, 0, 1.0)
setInterval(function() {
    draw(program, vertex, texture)
}, 33)
</code></pre>

<p><canvas id="triangle" class="imgright" style="background:#CCC"></p>

<script type="text/javascript">

    (function(){
    var canvas = document.getElementById('triangle')
      , gl = canvas.getContext('experimental-webgl')

    var frag = [''
    ,'#ifdef GL_ES'
    ,'precision highp float;'
    ,'#endif'
    ,'uniform float time;'
    ,'uniform sampler2D texture;'
    ,'void main() {'
    ,'    float x = time * 720.0;'
    ,'    x = sin(radians(x)) + 2.0;'
    ,'    x = x / 2.0;'
    ,'    vec4 texture_color = texture2D(texture, gl_FragCoord.xy/300.0);'
    ,'    vec4 x_vec = vec4(x, x, x, 1.0);'
    ,'    gl_FragColor = x_vec * texture_color;'
    ,'}'
    ].join('\n')

    var vert = [''
    ,'#ifdef GL_ES'
    ,'precision highp float;'
    ,'#endif'
    ,'attribute vec3 position;'
    ,'uniform float time;'
    ,'void main() {'
    ,'    float x = (sin(radians(time * 360.0)) + 2.0) / 2.0;'
    ,'    gl_Position = vec4(position * x, 1.0);'
    ,'}'
    ].join('\n')


    // here's our vertex data.
    var vertices = [
         -0.5, -0.5, 0
      ,   0.0,  0.5, 0
      ,   0.5, -0.5, 0
    ]


    // create a shader program &mdash; a strategy for
    // rendering OpenGL primitives &mdash; and send it
    // to the OpenGL server.
    function init_program() {
        var program = gl.createProgram()
          , vertex_shader = gl.createShader(gl.VERTEX_SHADER)
          , fragment_shader = gl.createShader(gl.FRAGMENT_SHADER)

        gl.shaderSource(vertex_shader, vert)
        gl.shaderSource(fragment_shader, frag)
        gl.compileShader(vertex_shader)
        gl.compileShader(fragment_shader)

        gl.attachShader(program, vertex_shader)
        gl.attachShader(program, fragment_shader)
        gl.linkProgram(program)
        return program
    }

    // send our vertex data to the OpenGL server.
    function init_vertex() {
        var buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW)
        return buffer
    }

    function load_texture(path) {
        // use the built in `Image` constructor provided to javascript.
        var img = new Image
          , texture = gl.createTexture()

        img.src = path

        img.onload = function() {
        // put the image data in the correct order for OpenGL.
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)

        // set the active texture object to `texture`.
        gl.bindTexture(gl.TEXTURE_2D, texture)

        // we want to write a 2D image, at the first level of detail,
        // to the current texture handle. store the data internally as (r,g,b,a).
        // the incoming data is already in (r,g,b,a) format, and it's defined in
        // unsigned bytes (0-255). pull that data from `img`.
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img)

        // as we get closer to the texture, use linear scaling to supersample the image.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)

        // as we get further away from the texture, use linear scaling to subsample the image.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)

        // set the behavior for sampling a coordinate from the texture outside of the width
        // of the image:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)

        // as well as outside the height of the image:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
        }

        return texture
    } 

    // we'll add a parameter for `texture` to our draw call:
    function draw(program, vertex, texture) {
        var time_location
          , texture_location

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
        gl.useProgram(program)
        time_location = program.time_location || gl.getUniformLocation(program, 'time')
        program.time_location = time_location

        // note: we cache the location of `uniform sampler2D texture` just
        // like the time.
        texture_location = program.texture_location || gl.getUniformLocation(program, 'texture')
        program.texture_location = texture_location

        // set the active texture unit to 0.
        gl.activeTexture(gl.TEXTURE0)

        // bind the texture to the current active texture unit.
        gl.bindTexture(gl.TEXTURE_2D, texture)

        // tell our program that the variable `uniform sampler2D texture` refers to texture unit 0.
        gl.uniform1i(texture_location, 0)

        gl.uniform1f(time_location, (Date.now() % 3000) / 3000)
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex)
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(0)
        gl.drawArrays(gl.TRIANGLES, 0, vertices.length/3)
    }

    var program = init_program()
      , vertex = init_vertex()
      , texture = load_texture('/media/img/painterly.jpg')

    gl.clearColor(0, 0, 0, 1.0)
    setInterval(function() {
        draw(program, vertex, texture)
    }, 33)

    })()
</script>

<p>Our texture is displayed on the triangle. However, there's a bit of a wrinkle: the texture isn't
being scaled along with the size of the triangle! We'd really like the texture to scale up and down,
but to do that we'll need <strong>texture coordinates</strong> associated with each vertex of the triangle.</p>

<blockquote>
  <h3 id="poweroftwotextures">Power of two textures</h3>
  
  <p>WebGL (and OpenGL in general) works best with
  power of two textures &mdash; that is, <code>256x256</code>, <code>512x512</code>.
  In particular, if a texture's dimensions are not a power of two,
  WebGL requires that we must use certain filtering (mipmapping is not allowed),
  as well as clamping for the texture to display &mdash; hence the <code>CLAMP_TO_EDGE</code> above.</p>
</blockquote>

<p>However, vertex attribute data isn't passed from the vertex shader to the fragment shader. It wouldn't make
sense to directly pass vertices in: in the fragment shader, we're working at the pixel level. There's no
association between the pixel we're working on and which vertex caused that pixel to be drawn.</p>

<p>Enter the <code>varying</code> qualifier. In our shaders, we can define variables as being <code>varying</code> &mdash; in the vertex shader,
this means that we'll be passing vertex-specific data into the variable. In the fragment shader, we'll be reading
that data back out. <strong>Nota bene</strong>: the values we assign to the varying variable in the vertex shader will not be
the exact same values we read back out in the fragment shader &mdash; remember, the pixel has no idea which vertex it
should be associated with. Instead, the values will be <strong>interpolated</strong> across the primitive created by the vertex
shader.</p>

<p>Let's take a look at the modifications we'll have to make to the vertex shader:</p>

<pre><code>#ifdef GL_ES
precision highp float;
#endif

attribute vec3 position;

// declare an [x, y] texcoord we'll be writing into.
varying vec2 texcoord;

uniform float time;

void main() {
    float x = sin(radians(time * 360.0)) + 2.0;

    x /= 2.0;

    gl_Position = vec4(position * x, 1.0);

    // pass our position data into the fragment shader.
    // move it into the [0, 1] space (remember, our [x,y,z] coords are [-0.5, 0.0, 0.0], etc)
    texcoord = position.xy + vec2(0.5, 0.5);
}
</code></pre>

<p>And our fragment shader:</p>

<pre><code>// our fragment shader:
#ifdef GL_ES
precision highp float;
#endif

uniform float time;

uniform sampler2D texture;

// declare that we'll be reading from the interpolated [x, y] texcoord from above.
varying vec2 texcoord;

void main() {
    float x = time * 720.0;
    x = sin(radians(x)) + 2.0;
    x = x / 2.0;

    // use our interpolated texcoord value to lookup a pixel in the texture.
    vec4 texture_color = texture2D(texture, texcoord);
    vec4 x_vec = vec4(x, x, x, 1.0);

    gl_FragColor = x_vec * texture_color;
}
</code></pre>

<p><canvas id="texcoord" class="imgright" style="background:#CCC"></p>

<script type="text/javascript">

    (function(){
    var canvas = document.getElementById('texcoord')
      , gl = canvas.getContext('experimental-webgl')

    var frag = [''
    ,'#ifdef GL_ES'
    ,'precision highp float;'
    ,'#endif'
    ,'uniform float time;'
    ,'uniform sampler2D texture;'
    ,'varying vec2 texcoord;'
    ,'void main() {'
    ,'    float x = time * 720.0;'
    ,'    x = sin(radians(x)) + 2.0;'
    ,'    x = x / 2.0;'
    ,'    vec4 texture_color = texture2D(texture, texcoord);'
    ,'    vec4 x_vec = vec4(x, x, x, 1.0);'
    ,'    gl_FragColor = x_vec * texture_color;'
    ,'}'
    ].join('\n')

    var vert = [''
    ,'#ifdef GL_ES'
    ,'precision highp float;'
    ,'#endif'
    ,'attribute vec3 position;'
    ,'uniform float time;'
    ,'varying vec2 texcoord;'
    ,'void main() {'
    ,'    float x = (sin(radians(time * 360.0)) + 2.0) / 2.0;'
    ,'    gl_Position = vec4(position * x, 1.0);'
    ,'    texcoord = position.xy + vec2(0.5, 0.5);'
    ,'}'
    ].join('\n')


    // here's our vertex data.
    var vertices = [
         -0.5, -0.5, 0
      ,   0.0,  0.5, 0
      ,   0.5, -0.5, 0
    ]


    // create a shader program &mdash; a strategy for
    // rendering OpenGL primitives &mdash; and send it
    // to the OpenGL server.
    function init_program() {
        var program = gl.createProgram()
          , vertex_shader = gl.createShader(gl.VERTEX_SHADER)
          , fragment_shader = gl.createShader(gl.FRAGMENT_SHADER)

        gl.shaderSource(vertex_shader, vert)
        gl.shaderSource(fragment_shader, frag)
        gl.compileShader(vertex_shader)
        gl.compileShader(fragment_shader)

        gl.attachShader(program, vertex_shader)
        gl.attachShader(program, fragment_shader)
        gl.linkProgram(program)
        return program
    }

    // send our vertex data to the OpenGL server.
    function init_vertex() {
        var buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW)
        return buffer
    }

    function load_texture(path) {
        // use the built in `Image` constructor provided to javascript.
        var img = new Image
          , texture = gl.createTexture()

        img.src = path

        img.onload = function() {
        // put the image data in the correct order for OpenGL.
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)

        // set the active texture object to `texture`.
        gl.bindTexture(gl.TEXTURE_2D, texture)

        // we want to write a 2D image, at the first level of detail,
        // to the current texture handle. store the data internally as (r,g,b,a).
        // the incoming data is already in (r,g,b,a) format, and it's defined in
        // unsigned bytes (0-255). pull that data from `img`.
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img)

        // as we get closer to the texture, use linear scaling to supersample the image.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)

        // as we get further away from the texture, use linear scaling to subsample the image.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)

        // set the behavior for sampling a coordinate from the texture outside of the width
        // of the image:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)

        // as well as outside the height of the image:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
        }

        return texture
    } 

    // we'll add a parameter for `texture` to our draw call:
    function draw(program, vertex, texture) {
        var time_location
          , texture_location

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
        gl.useProgram(program)
        time_location = program.time_location || gl.getUniformLocation(program, 'time')
        program.time_location = time_location

        // note: we cache the location of `uniform sampler2D texture` just
        // like the time.
        texture_location = program.texture_location || gl.getUniformLocation(program, 'texture')
        program.texture_location = texture_location

        // set the active texture unit to 0.
        gl.activeTexture(gl.TEXTURE0)

        // bind the texture to the current active texture unit.
        gl.bindTexture(gl.TEXTURE_2D, texture)

        // tell our program that the variable `uniform sampler2D texture` refers to texture unit 0.
        gl.uniform1i(texture_location, 0)

        gl.uniform1f(time_location, (Date.now() % 3000) / 3000)
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex)
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(0)
        gl.drawArrays(gl.TRIANGLES, 0, vertices.length/3)
    }

    var program = init_program()
      , vertex = init_vertex()
      , texture = load_texture('/media/img/painterly.jpg')

    gl.clearColor(0, 0, 0, 1.0)
    setInterval(function() {
        draw(program, vertex, texture)
    }, 33)

    })()
</script>

<p>Now our texture is scaling along with the size of the triangle. You may note some problems with our current approach.</p>

<ul>
<li>Our position information is our texture coordinate information. What if we want to change one without changing the other?</li>
<li><p>This is harder to notice, but you might see a flicker at the beginning of the render. This is caused by our texture loader:
When we're sending our texture image data to OpenGL, we haven't actually loaded the image yet. </p>

<p>In other words, we start rendering before we've actually loaded our texture! To solve this, we'll have to rework our texture
loader to use callbacks.</p></li>
<li>What if we want to change our texture parameters? Right now, you might note that when the texture is sub- or super-sampled,
the scaling looks a little blocky. What if we want our textures to repeat?</li>
</ul>

<p>It's not all doom and gloom, however &mdash; over the last three articles, we've gone from drawing a static, red triangle to drawing
an animated, pulsating triangle that displays textures. Importantly, <strong>note how little code we had to write to do this</strong>. Were
we programming against OpenGL using C or C++, we'd have to take into consideration:</p>

<ul>
<li>Platform specific code (not necessary with WebGL!)</li>
<li>System endianness (again, JavaScript and WebGL take care of that for us!)</li>
<li>Writing image loaders for every image type we wanted to use (all we have to do in WebGL is just load an image and pass it to
OpenGL!)</li>
</ul>

<p>So, keeping in mind how much we have specifically not had to learn, let's approach those three problems we listed above optimistically!
I promise the solutions will be short and sweet.</p>

<h2 id="makingourtextureloadertakecallbacks">Making our texture loader take callbacks</h2>

<p>This is probably the easiest problem to tackle, but might be a little difficult if you're not well-versed in how JavaScript works.</p>

<p>If you're comfortable with transforming synchronous code into asynchronous code in JS, you can feel free to skip this section.</p>

<p>In brief, JavaScript, unlike many language, has the concept of an <strong>event loop</strong> baked in. In other words, your program does not
exit once the stack is exhausted, unlike many other languages. You may schedule events to happen later, at which point your code
will execute in a new stack: references to variables in your function's scope will be retained, so the process is painless.</p>

<p>In the browser, we may hook onto document-wide events, element-specific events, or event events triggered by an object.</p>

<p>In particular, we'd like our texture loader to have an api like the following:</p>

<pre><code>load_texture('/path/to/texture.png', function(error, texture) {
    // if we couldn't load the texture, skip out early.
    if(error) throw error;

    // otherwise create the game loop.
    setInterval(function() {
        draw(program, vertex_buffer, texture)
    }, 33)
})
</code></pre>

<p>It turns out that we can do this with a minimal amount of contortion on our part. A rule of thumb: it's easier to write
your code as if it will be asynchronous by default &mdash; even when it won't be &mdash; than it is to keep revisiting synchronous code
and rewriting it to be async. Furthermore, in JavaScript, it's entirely possible to make synchronous code act asynchronous, but it's very difficult
to make asynchronous code act synchronously.</p>

<p>Going forward we'll write our loading functions with those properties in mind. For now, let's revisit our image loader:</p>

<pre><code>// add a `ready` parameter that will act as our callback.
function load_texture(path, ready) {
    var img = new Image
      , texture = gl.createTexture()

    img.src = path

    // javascript will automatically "hoist" the `loaded` and `error` functions to the top of
    // the scope, so they're available here:
    img.onload = loaded
    img.onerror = error

    function loaded () {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)
        gl.bindTexture(gl.TEXTURE_2D, texture)
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

        // there was no error, so we'll pass `null` for 
        // the error parameter, and `texture` as the data parameter.
        ready(null, texture)
    }

    function error () {
        // there was an error, so we'll call the `ready` 
        // callback with a `new Error` as it's error parameter.
        ready(new Error('Could not load '+path))
    }
} 
</code></pre>

<p>Now our image loader works as it should: it delays defining the texture until the image is fully loaded. It'll also give us
a handy "error" if the image failed to load.</p>

<h2 id="makingourtextureloaderattempttomipmapandrepeat">Making our texture loader attempt to mipmap and repeat.</h2>

<p>As mentioned previously, WebGL is particularly picky about textures that are not a power of two on each side: <code>256x256</code>, <code>512x512</code>,
etc. are all fine, and we have all the configuration options in the world available to us, but when we're faced with an oddly sized texture
(as our current texture currently is), we can only use <code>LINEAR</code> filtering, and we must <code>CLAMP_TO_EDGE</code> when we're outside the bounds of the texture.</p>

<p>This kind of sucks.</p>

<p>In an ideal world, we would be able to specify any clamping or mag/min filtering options, and if they're not supported by the texture as is,
we would resize said texture to a power of two and retry. Our ideal defaults are to use mipmapping (which ensures a smooth sub-sampling scheme),
and a repeating stategy for texture wrapping.</p>

<p><a href="#canvas-resizing">I'll use the canvas texture resizer from this article</a>, which is defined as <code>resize_image(image)</code>, and returns a <code>canvas</code> object
that we can pass to OpenGL as our image. We'll modify our <code>load_texture</code> to optionally accept <code>options</code> as a hash of option values, with sane
defaults built into the function.</p>

<pre><code>// add a `ready` parameter that will act as our callback.
function load_texture(path, options, ready) {
    var img = new Image
      , texture = gl.createTexture()
      , defaults = {
            wrap:'repeat'
          , mag:'linear'
          , min:'mipmap'
        }
      , map_options_to_gl = {
            repeat:gl.REPEAT
          , clamp:gl.CLAMP_TO_EDGE
          , linear:gl.LINEAR
          , mipmap:gl.LINEAR_MIPMAP_LINEAR
          , nearest:gl.NEAREST
        }

    // if we only passed two arguments in, reorder the arguments.
    if(ready === undefined) {
        ready = options
        options = {}
    }

    // reduce our options into a single options object,
    // transforming the options into their gl equivalents. 
    // if an option is invalid, attempt to use the default value.
    options = [defaults, options].reduce(function(lhs, rhs) {
      for(var key in rhs) {
        lhs[key] = map_options_to_gl[rhs[key]] || map_options_to_gl[lhs[key]]
      } 
      return lhs
    }, {})

    img.src = path
    img.onload = loaded
    img.onerror = error

    function loaded () {
        // if the width and height are different
        // or if the width isn't a power of two, it's a npot texture.
        var is_npot = img.width !== img.height || !(img.width &amp; (img.width - 1)) === 0

        // if we've got an npot texture and our options 
        // request something other than clamping or
        // linear sub-sampling, resize it. 
        if(is_npot &amp;&amp; (options.clamp !== gl.CLAMP_TO_EDGE || options.min !== gl.LINEAR)) {
          img = resize_image(img)
        }

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)
        gl.bindTexture(gl.TEXTURE_2D, texture)
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img)

        if(options.min === gl.LINEAR_MIPMAP_LINEAR) {
          gl.generateMipmap(gl.TEXTURE_2D)
        }

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, options.mag)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, options.min)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.clamp)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.clamp)
        ready(null, texture)
    }

    function error () {
        ready(new Error('Could not load '+path))
    }
} 
</code></pre>

<h2 id="addingattributestoourvertexstream">Adding attributes to our vertex stream</h2><!--/ins-->
    </div>
</div>
<footer class="centered">
    <div>
        <a href="http://github.com/chrisdickinson/" target="_blank">
            <img src="https://secure.gravatar.com/avatar/f70956bdb907c2f8b39ff624ea925ccd?s=140" />
        </a>
        <aside>
        <p><em>Chris Dickinson</em> is a hacker living in Lawrence, KS.
        <p>He enjoys drawing, coffee, Starcraft, and chatting about JavaScript.
        <p>You can follow him <a href="http://twitter.com/isntitvacant/">on twitter</a> or
           <a href="http://github.com/chrisdickinson/">on github</a>. He&rsquo;d very much appreciate
           it!
        </aside>
    </div>
</footer>
<script src="/media/js/showdown.js"></script>
<script src="/media/js/highlight.js"></script>
<script>[].slice.call(document.getElementsByTagName('code')).forEach(function(el) { hljs.highlightBlock(el, '  ') })</script>
<script src="/media/js/page.js"></script>
