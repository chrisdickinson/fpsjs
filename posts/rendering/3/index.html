<!doctype html>
<meta charset="utf-8">
<title>FPS.js</title>
<link rel="stylesheet" href="/fpsjs/media/css/styles.css" />
<link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/default.min.css" />
<header class="centered">
    <div>
    <h1><a href="/">Building a networked FPS in the browser</a></h1>
    </div>
</header>
<div class="centered">
    <div id="container">
        <h1 id="cameraselementarraybuffersandprimitives">Cameras, element array buffers, and primitives.</h1>

<p>Up until this article, we've been satisfied with drawing a simple, two-dimensional triangle to the screen.
By this point we've got a fairly complete mental model of what resources we need to draw an element to a screen. 
There are three final concepts I'd like to introduce at this point: <strong>primitives</strong>, <strong>view matrices</strong>, and 
<strong>element array buffers</strong>. By the end of the article, we should be able to create a general purpose resource loader,
and define a format for our resources. We'll also start using <a href="http://paulirish.com/2011/requestanimationframe-for-smart-animating/"><code>requestAnimFrame</code></a> to schedule our draw call (up until now, we've used <code>setInterval</code>). The linked article does a much
better job of explaining the benefits of this approach; so we won't worry ourselves overly much with it at the moment.</p>

<h2 id="primitives">Primitives</h2>

<pre><code>    gl.drawArrays(gl.TRIANGLES, 0, vertices.length/3)
</code></pre>

<p>We've been using this <code>drawArrays</code> call <a href="#rendering">since the first article in the series</a>. It's an old friend by now.
We talked about how, in this call, we're asking WebGL to draw <code>TRIANGLES</code> from the first element in our buffer until we
hit <code>vertices.length/3</code> &mdash; basically asking it, "draw <code>N</code> triangles for us". That abstraction works, but we're only talking
about the last two arguments, really: we never discussed different options for that first argument, <code>gl.TRIANGLES</code>.</p>

<p>Let's talk about <code>gl.TRIANGLES</code>, briefly. Hypothetically, what would a square look like if we wanted to draw it using
<code>gl.TRIANGLES</code>? Well, we'd need two triangles to make a square, and three vertices to draw a triangle. Past that, we need
three coordinates to make up those three vertices &mdash; <code>x, y, z</code>. That means we end up needing <code>3 (coordinates) * 3 (vertices) * 2</code>
to draw a square. </p>

<p><strong><code>18</code></strong> floating point numbers to define a square! Let's look at the data we're sending:</p>

<pre><code>[ 0, 0, 0   // first triangle
, 0, 1, 0
, 1, 1, 0
, 0, 1, 0   // second triangle
, 1, 1, 0
, 1, 0, 0 ]
</code></pre>

<p>How much unique data is in that data, really?</p>

<pre><code>[ 0, 0, 0   // a
, 0, 1, 0   // b
, 1, 0, 0   // c
, 1, 1, 0 ] // d

/* b --- d
   | \   |
   |  \  |
   |   \ |
   a --- c */
</code></pre>

<p>It turns out, since the two triangles share an edge, we can get away with only four vertices to define the square.
Specifically, we just need to add one vertex to define a new triangle. It will share the last edge defined, and create
two new edges to define the second triangle.</p>

<h2 id="anoteonwinding">A note on winding</h2>

<blockquote>
  <p>The above method of defining triangles is called <code>gl.TRIANGLE_STRIP</code>. It treats every vertex past the first 3 vertexes defined
  as a new triangle &mdash; an incredible improvement over our previous situation, where each triangle necessitated 3 entire vertices
  all to itself. It interacts with the <strong>winding</strong> in an interesting way: every odd triangle drawn is technically wound
  counter clockwise, but OpenGL knows that we're using a <code>TRIANGLE_STRIP</code> and treats those triangles as if they were wound
  clockwise.</p>
</blockquote>

<p>OpenGL will attempt to skip primitives
that are facing away from the camera position.</p>

<p>It can determine this by looking at the <em>winding</em> of the
primitive. Specifically, it attempts to cull polygons that are
wound counter-clockwise, with respect to the camera.</p>

<p>In other words, we define the first triangle as <code>a, b, c</code> --
bottom left, top left, bottom right. Were this triangle defined
as <code>a, c, b</code>, the winding would be counter-clockwise.</p>

<p>You can mentally model this by tracing the path that the triangle
in being drawn &mdash; if it goes from the left to the right to the top,
it is wound counterclockwise and will be culled.</p>

<h2 id="downsidesoftriangle_strip">Downsides of <code>TRIANGLE_STRIP</code></h2>

<p>This approach is not without it's downsides, however. We still have to repeat a lot of information, in certain cases. 
Imagine for a second that we're attempting to draw a cube with <code>gl.TRIANGLE_STRIP</code>. We would have to send the following information
to the GPU:</p>

<pre><code>[ 0, 0, 0   // a
, 0, 1, 0   // b
, 1, 0, 0   // c
, 1, 1, 0   // d
, 1, 0, 1   // e
, 1, 1, 1   // f
, 0, 1, 0   // b *
, 0, 1, 1   // g
, 1, 0, 1   // e *
, 0, 0, 1   // h
, 1, 0, 0   // c *
, 0, 0, 0   // a *
, 0, 1, 1   // g * 
, 0, 1, 0 ] // b *

/*
        g --- f
      / |   / |
    b ---- d  |
    |   |  |  |
    |   h -|- e
    | /    | /
    a ---- c 
*/
</code></pre>

<p>We end up repeating vertex information &mdash; <strong>six</strong> times! Visualize that extra data in terms of bytes:
<code>3 * sizeof(float) * 6</code> is <strong><code>72</code></strong> extra bytes sent to the GPU that it must keep in memory, making less room for 
more interesting data, like textures or other models. </p>

<p>Our ideal situation is that all data present on the GPU be <em>unique</em>. Hence, in this situation, it would be beneficial
if we could simply send the unique vertices of the cube to the GPU, and refer to the vertices using a well-known name
per vertex &mdash; "draw vertices <code>a-b-c-d-e-f-b-g-e-h-c-a-g-b</code>". It'd be simplest to implement the vertex offset as the naming scheme &mdash; <code>a</code> is the vertex we sent at the <code>0</code>th position, <code>d</code> is at the <code>3</code>rd position, and so on. The memory advantages would be huge: instead of sending <code>72</code> extra bytes, we could compress that (assuming 1-byte indices) into <code>14</code> bytes of element offsets!</p>

<p>Luckily, OpenGL affords us this convenience, through the <code>gl.drawElements</code> command:</p>

<pre><code>gl.drawElements(gl.TRIANGLE_STRIP, number_of_elements, size_of_index, initial_offset)
</code></pre>

<h2 id="elementarraybuffers">Element Array Buffers</h2>

<h2 id="viewmatrices">View Matrices</h2>

<h3 id="asimplecameraclass">A simple camera class</h3>

<h3 id="ourresourceformatandloader">Our resource format and loader</h3><!--/ins-->
    </div>
</div>
<footer class="centered">
    <div>
        <a href="http://github.com/chrisdickinson/" target="_blank">
            <img src="https://secure.gravatar.com/avatar/f70956bdb907c2f8b39ff624ea925ccd?s=140" />
        </a>
        <aside>
        <p><em>Chris Dickinson</em> is a hacker living in Lawrence, KS.
        <p>He enjoys drawing, coffee, Starcraft, and chatting about JavaScript.
        <p>You can follow him <a href="http://twitter.com/isntitvacant/">on twitter</a> or
           <a href="http://github.com/chrisdickinson/">on github</a>. He&rsquo;d very much appreciate
           it!
        </aside>
    </div>
</footer>
<script src="/fpsjs/media/js/showdown.js"></script>
<script src="/fpsjs/media/js/highlight.js"></script>
<script>[].slice.call(document.getElementsByTagName('code')).forEach(function(el) { hljs.highlightBlock(el, '  ') })</script>
<script src="/fpsjs/media/js/page.js"></script>
